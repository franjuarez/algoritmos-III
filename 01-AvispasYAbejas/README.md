## Francisco Juárez (107748) y Juan Pablo Aschieri (108000)
 
*Los tests 01, 02 y 03 demuestran la funcionalidad de cómo se incrementa la cantidad de huevos de avispas a medida que los van dejando. Cuando los implementaste, ¿esos tests pasaron (los tres) de una? ¿podrías haber implementado esta funcionalidad de a partes, haciendo que pase el 01, luego el 01 y el 02 y por último el 01, 02 y 03? ¿se te ocurre cómo? Y si lograste hacerlo, ¿qué pensas de implementar esa funcionalidad de esa forma?*
 
A la hora de implementar el codigo, nostros utilizamos la ley del mas vago, es decir, ir codeando nada mas lo necesario para que vaya pasando las pruebas una a la vez. A tal punto que al inicio cuando solo tenia que pasar 1 prueba "hardcodeabamos" el codigo para que pase la misma. Esto por supuesto no duro mucho, ya que en la segunda prueba era imposible mantener ambas funcionando harcodeando el codigo. Asi de a poco fuimos avanzando y modificando el codigo, implementado las funcionalidades necesarias a medida que fueran apareciendo. Esto ayudo fuertemente a la hora de organizar el orden en el que se implementaban las funcionalidades, y a mantener mas simple la implementación.
 
 
*Responsabilidad de dejar un huevo consumiendo otro insecto ¿Quién les quedó, en su modelo, que es el responsable de ver si hay suficientes polillas u orugas y entonces dejar un huevo? ¿el insecto (Polly, Oriana, etc) o el hábitat? ¿por qué? ¿por qué tendría sentido que fuera de la otra forma? ¿con cuál nos quedamos?*
 
En nuestro modelo las responsabilidades de saber cuantos elementos (orugas, polillas, huevos) hay son del habitat, mientras que la responsabilidad de dejar un huevo en si es de la avispa. En cuanto a las orugas y polillas es bastante claro, ya que la avispa, si bien las utiliza para reproducirse no tiene una relación directa y en el dominio de nuestro problema no tiene sentido que una avispa sepa cuantas orugas o polillas hay en todo el habitat. Por el otro lado, la responsabilidad de los huevos es un poco mas difusa, y hasta podríamos hablar de una responsabilidad compartida. Esto debido a que, aunque la responsabilidad de poner un huevo recae en la avispa, la responsabilidad de saber cuantos hay es del habitat. Es por esto que la avispa se comunica con el habitat para que luego este ultimo aumente en 1 la cantidad de huevos. Es por esta dualidad de las responsabilidades con respecto a los huevos que se podría pensar de la otra forma. Bajo nuestro punto de vista la forma en la que lo implementamos distribuye las responsabilidades de la manera mas clara, es decir, que la avispa se hace cargo de avisarle al habitat cuando puso un nuevo huevo y el habitat tiene la responsabilidad de saber cuantos hay.
 
 
*¿les quedó código repetido? ¿dónde? ¿Se animan a adivinar qué cosa del dominio les faltó representar (y por eso tienen código repetido)? Con lo que vimos en la clase del Jueves (en la parte teórica, prototipos vs clases) ¿cómo sacarían este código?*
 
Un lugar que nos quedo codigo repetido fue en los métodos de intentarReproducirse y firmaGenetica. Todos realizan algo extremadamente similar, por ejemplo para intentarReproducirse, se chequea si hay suficiente de algo, si lo hay se elimina 1 de ese algo y se deja un huevo de alguna firma. Nos falto representar una avispa generica es decir una clase "Avispa" que modele el comportamiento generico que comparten todas las avispas representadas. Esta nos ayudaría, ya que tendríamos un único método que sería válido para todas las avispas.
 
 
*Sobre la implementación ¿cómo resolvieron guardar los huevos? ¿Usaron colecciones? ¿Diccionarios? ¿Uno, varios? ¿con qué indexaban? Pero la pregunta más importante: ¿es lo más sencillo que hacía falta? ¿o se podía hacer menos y todo andaba?*
 
Para almacenar los huevos decidimos utilizar un diccionario que tenía como claves a las firmas genéticas de las avispas y como valor la cantidad de huevos de cada firma. Decidimos usar un diccionario ya que mejora la prolijidad y simplicidad del código al evitar tener muchos colaboradores internos. Si bien uno podría definir las cantidades como colaboradores internos de manera sencilla y todo funcionaria, creemos que utilizar un diccionario no agrega ninguna complejidad mayor, es más, nos sirvió en varias partes para acortar el código, como para reiniciar la cantidad de huevos.
Como detalle extra pasamos a contar un parte de la implementación. Para intentarReproducirse de Lara pensamos 2 implementaciones. Una, la que entregamos que utiliza un ifTrue para chequear si Lara puede reproducirse y de ser posible ejecuta el resto. La otra forma de implementarlo trataba de evitar el uso del ifTrue. Para esto a la hora de fijarnos a que firma genética Lara le podía robar un huevo, si no había ningún huevo de otra firma se devolvía la firma genética de Lara. Entonces luego, se quitaba un huevo de Lara y se le sumaba uno, haciendo que efectivamente quede igual. Finalmente optamos por la primera, ya que la segunda resultaba menos legible y era mas compleja que simplemente usar un ifTrue.
